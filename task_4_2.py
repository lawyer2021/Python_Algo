# 2. Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»
# Примечание ко всему домашнему заданию:
# Проанализировать скорость и сложность алгоритмов.
# Результаты анализа сохранить в виде комментариев в файле с кодом.

# Без использования «Решета Эратосфена»:

from time import perf_counter

num = int(input("Введите номер искомого простого числа: "))
start = perf_counter()
numbers = [i for i in range(2, 10001)]
prime = []
not_prime = []
for i in numbers:
    test = True
    for d in range(2, i // 2 + 1):
        if i % d == 0:
            not_prime.append(i)
            test = False
            break
    if test:
        prime.append(i)
print("Simple number (var 1): ", prime[num - 1])
print("time 1: ", perf_counter() - start)

# Используя алгоритм «Решето Эратосфена»:

start = perf_counter()
a = [i for i in range(10001)]
a[1] = 0
m = 2
while m < len(a):
    if m != 0:
        j = m * 2
        while j < len(a):
            a[j] = 0
            j += m
    m += 1
print("Simple number (var 2): ", ([i for i in a if i !=0][num-1]))
print("time 2: ", perf_counter() - start)

# Скорость выполнения второго варианта алгоритма почти в 16 раз меньше первого вне зависимости от количества искомого значения
# Сложность первого алгоритма выше, т.к. происходит обход 1/2 чисел массива заданной длины.
# Оба алгоритма состоят из двух вложенных циклов, но преимуществом решета Эратосфена является то, что проход цикла происходит не по всем числам, а только зануливание непростых чисел.
# В результате чего в изначальном списке остаются тольк простые числа. Кроме того, в первом алгоритме используется создание циклами двух списков (простых и непростых чисел),
# что также отражается на скорости общего выполнения.
